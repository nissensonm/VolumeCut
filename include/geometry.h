
#ifndef GEOMETRY_H
#define GEOMETRY_H

#include <iostream>
#include <math.h>
#include <string.h>
#include <map>
#include <utility>

#include "utilityfunctions.h"
#include "Matrix.h"



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// List Of Data Structures //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct Coordinate{
	double x,
		   y,
		   z;
	//Initiate values to 0.0
	Coordinate() : x(0.00),
					y(0.00),
					z(0.00) {}
};

// DATA STRUCTURE TO STORE PHI AND PSI ANGLES
struct Torsion
{
	double phi;
	double psi;
	//Initialize torsion angles to 999.00
	Torsion() : phi(999.00), psi(999.00) {}
};


#define PI  3.1415926535897932384626433832  // Pi

#define ABS(x)     ((x) >= 0 ? (x) : -(x))   // absolute value

#define SQR(x)   (x * x)  //square function

// convert from radian to degree
#define toDegree(radian) \
	((double) (radian * 180) / PI)

// converts from degree to radian
#define toRadian(degree) \
	((double) (degree * PI) / 180)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// End Of Constants and Data Structures /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// List of Functions ////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double ge(Matrix A, Matrix b, Matrix & x);												//Function to perform Gaussian elimination to solve A*x = b
double linePointIntersection(Coordinate lineP1, Coordinate lineP2, Coordinate p, Coordinate &intersectionPnt);	//same as "pointLineIntersection"..but it looks faster
double getDistance(Coordinate p1, Coordinate p2);										//calculate the distance b/w 2 points
Coordinate triangleCenter(Coordinate p1, Coordinate p2, Coordinate p3);					//return the center point for a triangle
Coordinate pointOnLine(Coordinate p1, Coordinate p2, double dist);						//find a point on line P1-P2 that far from P2 dist toward P2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// ////////// End Of The List //////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// Vectors CLASS ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Vectors
{
public:

	// Constructors
	Vectors();
	Vectors(Coordinate);
	Vectors(double, double, double);
	Vectors(Coordinate,Coordinate);


	void operator+=(Vectors);		//sum 2 vectors
	void operator+=(Coordinate);	//sum a point to the vector
	void operator+= (double);		//sum a number to the vector
	void operator-=(Vectors);		//subtract a vector from the vector
	void operator-=(Coordinate);	//subtract a point from the vector
	void operator-= (double);		//subtract a number from the vector
	void set(Coordinate,Coordinate);	//given 2 points...set the vector
	void set(Coordinate);				//given  a point make the vector equal this point

	Vectors mul(double);				//multiply the vector by a number
	void divide(double);				//divide the vector by a number
	Vectors getDiff(Vectors);			//get the difference b/w 2 vectors

	double dot(Vectors);				//calculate the dot product
	double getDistance(Vectors);		//calculate the distance be/w 2 vectors
	double length();					//calculate the length of the vector


	Coordinate getCoordinates();		//convert the from Vectors class to Coordinate data Type
	double getX();						//return the value of x coordinate
	double getY();						//return the value of y coordinate
	double getZ();						//return the value of z coordinate


private:
	double  x_,
			y_,
			z_;

};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// End of Vectors CLASS ///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Implementation of Vectors CLASS /////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Vectors::Vectors()		///////constructors/////
{
	x_ = 0;
	y_ = 0;
	z_ = 0;
}
Vectors::Vectors(Coordinate p)	///////constructors/////
{
	x_	= p.x;
	y_	= p.y;
	z_	= p.z;
}
Vectors::Vectors(double xPrime, double yPrime, double zPrime)		///////constructors/////
{
	x_	= xPrime;
	y_	= yPrime;
	z_	= zPrime;
}
Vectors::Vectors(Coordinate p1,Coordinate p2)			///////constructors/////
{
	x_ = p2.x - p1.x;
	y_ = p2.y - p1.y;
	z_ = p2.z - p1.z;
}
///////////////////////////////////////////////////////////////////////

double Vectors::getDistance(Vectors v)
{
	double xDist = v.x_ - x_;
	double yDist = v.y_ - y_;
	double zDist = v.z_ - z_;
	return sqrt(xDist*xDist + yDist*yDist + zDist*zDist);
}
//////////////////////////////////////////////////////////////////////////
Vectors Vectors::getDiff(Vectors v)
{
// computes the difference b/w the vector with vector v
	Vectors tmpVect;
	tmpVect.x_	= x_ - v.x_;
	tmpVect.y_	= y_ - v.y_;
	tmpVect.z_	= z_ - v.z_;
	return tmpVect;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator+=(Vectors v)
{
	x_ += v.x_;
	y_ += v.y_;
	z_ += v.z_;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator+=(Coordinate p)
{
	x_ += p.x;
	y_ += p.y;
	z_ += p.z;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator+= (double num)
{
	x_ += num;
	y_ += num;
	z_ += num;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator-=(Vectors v)
{
	x_ -= v.x_;
	y_ -= v.y_;
	z_ -= v.z_;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator-= (Coordinate p)
{
	x_ -= p.x;
	y_ -= p.y;
	z_ -= p.z;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::operator-= (double num)
{
	x_ -= num;
	y_ -= num;
	z_ -= num;
}
///////////////////////////////////////////////////////////////////////////
Vectors Vectors::mul(double num)
{
//Multiply a vector by number
	Vectors tmp;
	tmp.x_	= x_ * num;
	tmp.y_	= y_ * num;
	tmp.z_	= z_ * num;
	return tmp;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::divide (double num)
{
	Vectors tmp;
	x_ /= num;
	y_ /= num;
	z_ /= num;
}
///////////////////////////////////////////////////////////////////////////
double Vectors::dot(Vectors v)
{
// A . B = Ax*Bx + Ay*By + Az*Bz
	return ((x_ * v.x_)+ (y_ * v.y_) + (z_ * v.z_));
}
///////////////////////////////////////////////////////////////////////////
void Vectors::set(Coordinate p1,Coordinate p2) //p2 - p1
{
	x_ = p2.x - p1.x;
	y_ = p2.y - p1.y;
	z_ = p2.z - p1.z;
}
///////////////////////////////////////////////////////////////////////////
void Vectors::set(Coordinate p)
{
	x_	= p.x;
	y_	= p.y;
	z_	= p.z;
}
///////////////////////////////////////////////////////////////////////////
Coordinate Vectors::getCoordinates()
{
	Coordinate p;
	p.x = x_;
	p.y = y_;
	p.z = z_;
	return p;
}
///////////////////////////////////////////////////////////////////////////
double Vectors::getX()
{
	return x_;
}
///////////////////////////////////////////////////////////////////////////
double Vectors::getY()
{
	return y_;
}
///////////////////////////////////////////////////////////////////////////
double Vectors::getZ()
{
	return z_;
}
///////////////////////////////////////////////////////////////////////////
double Vectors::length()
{
	return sqrt(x_ * x_ + y_ * y_ + z_ * z_);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// END OF VECTORS CLASS IMPLEMENTATION///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//given a line and a point, returns the point where these two intersect
//it looks faster than the other one "Coordinate pointLineIntersection(Coordinate p1,Coordinate p2,Coordinate p3)"
double linePointIntersection(Coordinate lineP1, Coordinate lineP2, Coordinate p, Coordinate &intersectionPnt){

	//create the vectors represents the line and a nother vector represents a line from lineP1 and the point p
	Vectors v1(lineP2, lineP1), v2(p,lineP1);

	double dotProd = v1.dot (v2);
	double lineLengthSqr = (lineP2.x - lineP1.x)*(lineP2.x - lineP1.x) + (lineP2.y - lineP1.y)*(lineP2.y - lineP1.y) + (lineP2.z - lineP1.z)*(lineP2.z - lineP1.z);

	double e = dotProd/lineLengthSqr;


	intersectionPnt.x = lineP1.x + e * (lineP2.x - lineP1.x);
	intersectionPnt.y = lineP1.y + e * (lineP2.y - lineP1.y);
	intersectionPnt.z = lineP1.z + e * (lineP2.z - lineP1.z);

	/*
	if e is :
		negative	: the intersection point is before point#1 in the line
		0			: the intersection point is on the first point
		b/w (0,1)	: the intersection point is on the line
		> 1			: the intersection point is after the second point in the line
	*/
	return e;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//compute the distance b/w 2 given points
double getDistance(Coordinate p1, Coordinate p2)
{
	return sqrt(((p1.x - p2.x)*(p1.x - p2.x)) + ((p1.y - p2.y)*(p1.y - p2.y)) + ((p1.z - p2.z)*(p1.z - p2.z)));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// calculate the center of triangle represented by three points
Coordinate triangleCenter(Coordinate p1, Coordinate p2, Coordinate p3)
{
	Coordinate p;

	p.x = (p1.x + p2.x + p3.x)/3;
	p.y = (p1.y + p2.y + p3.y)/3;
	p.z = (p1.z + p2.z + p3.z)/3;

	return p;

}

//////////////////////////////////////////////////////////////////////////////////////////
// given a line represent by p1-p2... find a point located on this line but has dist from p1 in the direction of p2
// dist = 0 return p1....dist = dist from p1 to p2 will return p2...
Coordinate pointOnLine(Coordinate p1, Coordinate p2, double dist)
{
	Vectors Pa(p1), Pab(p1, p2),
			Pc;

	double distPercantage = dist/Pab.length();

	Pc = Pab.mul(distPercantage);
	Pc += Pa;

	return Pc.getCoordinates();
}

//////////////////////////////////////////////////////////////////////////////////////////////////
#endif
